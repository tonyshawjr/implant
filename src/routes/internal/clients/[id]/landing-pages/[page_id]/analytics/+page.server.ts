import type { PageServerLoad } from './$types';
import { prisma } from '$lib/server/db';
import { error } from '@sveltejs/kit';
import { startOfDay, addDays } from '$lib/utils';

export const load: PageServerLoad = async ({ params }) => {
  const { id: organizationId, page_id: landingPageId } = params;

  // Load landing page details
  const landingPage = await prisma.landingPage.findFirst({
    where: {
      id: landingPageId,
      organizationId
    },
    select: {
      id: true,
      name: true,
      slug: true,
      url: true,
      status: true,
      viewCount: true,
      submissionCount: true,
      conversionRate: true,
      publishedAt: true,
      createdAt: true,
      updatedAt: true,
      config: true,
      template: {
        select: {
          id: true,
          name: true,
          category: true
        }
      },
      campaign: {
        select: {
          id: true,
          name: true,
          platform: true
        }
      },
      organization: {
        select: {
          id: true,
          name: true,
          slug: true
        }
      }
    }
  });

  if (!landingPage) {
    throw error(404, 'Landing page not found');
  }

  // Calculate date range (last 30 days)
  const now = new Date();
  const thirtyDaysAgo = startOfDay(addDays(now, -30));

  // Load leads generated by this landing page (via utm tracking or source detail)
  // Leads are linked via the campaign or source detail containing the landing page name
  const leads = await prisma.lead.findMany({
    where: {
      organizationId,
      OR: [
        // Leads from the associated campaign
        landingPage.campaign?.id ? { campaignId: landingPage.campaign.id } : {},
        // Leads with source detail mentioning this landing page
        { sourceDetail: { contains: landingPage.name } }
      ].filter(condition => Object.keys(condition).length > 0)
    },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      email: true,
      phone: true,
      status: true,
      temperature: true,
      score: true,
      source: true,
      utmSource: true,
      utmMedium: true,
      utmCampaign: true,
      utmContent: true,
      createdAt: true,
      convertedAt: true
    },
    orderBy: {
      createdAt: 'desc'
    }
  });

  // Calculate metrics
  const totalViews = landingPage.viewCount || 0;
  const totalSubmissions = landingPage.submissionCount || 0;
  const conversionRate = totalViews > 0
    ? Math.round((totalSubmissions / totalViews) * 10000) / 100
    : 0;

  // Calculate average lead score
  const leadsWithScores = leads.filter(l => l.score !== null);
  const avgLeadScore = leadsWithScores.length > 0
    ? Math.round(leadsWithScores.reduce((sum, l) => sum + (l.score || 0), 0) / leadsWithScores.length)
    : 0;

  // Lead temperature distribution
  const temperatureDistribution = {
    hot: leads.filter(l => l.temperature === 'hot').length,
    warm: leads.filter(l => l.temperature === 'warm').length,
    cold: leads.filter(l => l.temperature === 'cold').length
  };

  // Traffic sources breakdown (group by utm_source)
  const trafficSourcesMap = new Map<string, number>();
  leads.forEach(lead => {
    const source = lead.utmSource || lead.source || 'direct';
    trafficSourcesMap.set(source, (trafficSourcesMap.get(source) || 0) + 1);
  });

  const trafficSources = Array.from(trafficSourcesMap.entries())
    .map(([source, count]) => ({
      source,
      count,
      percentage: leads.length > 0 ? Math.round((count / leads.length) * 100) : 0
    }))
    .sort((a, b) => b.count - a.count);

  // UTM campaign breakdown
  const utmCampaignsMap = new Map<string, { count: number; leads: typeof leads }>();
  leads.forEach(lead => {
    const campaign = lead.utmCampaign || 'No Campaign';
    const existing = utmCampaignsMap.get(campaign) || { count: 0, leads: [] };
    existing.count++;
    existing.leads.push(lead);
    utmCampaignsMap.set(campaign, existing);
  });

  const utmCampaigns = Array.from(utmCampaignsMap.entries())
    .map(([campaign, data]) => {
      const hotLeads = data.leads.filter(l => l.temperature === 'hot').length;
      const warmLeads = data.leads.filter(l => l.temperature === 'warm').length;
      return {
        campaign,
        count: data.count,
        percentage: leads.length > 0 ? Math.round((data.count / leads.length) * 100) : 0,
        hotLeads,
        warmLeads,
        qualityScore: data.count > 0
          ? Math.round(((hotLeads * 3 + warmLeads * 2) / (data.count * 3)) * 100)
          : 0
      };
    })
    .sort((a, b) => b.count - a.count);

  // Generate views and submissions by day (last 30 days)
  // Since we don't track daily views separately, we'll estimate based on lead creation dates
  const dateMap = new Map<string, { views: number; submissions: number }>();

  // Initialize all dates
  for (let i = 0; i < 30; i++) {
    const date = startOfDay(addDays(now, -i));
    const dateKey = date.toISOString().split('T')[0];
    dateMap.set(dateKey, { views: 0, submissions: 0 });
  }

  // Count leads per day as submissions proxy
  leads.forEach(lead => {
    const dateKey = lead.createdAt.toISOString().split('T')[0];
    const existing = dateMap.get(dateKey);
    if (existing) {
      existing.submissions++;
      // Estimate views based on average conversion rate (or use 10% as baseline)
      const estimatedConversionRate = conversionRate > 0 ? conversionRate / 100 : 0.1;
      existing.views = Math.round(existing.submissions / estimatedConversionRate);
    }
  });

  const viewsByDay = Array.from(dateMap.entries())
    .map(([date, data]) => ({
      date,
      views: data.views,
      submissions: data.submissions
    }))
    .sort((a, b) => a.date.localeCompare(b.date));

  // Calculate conversion funnel stages
  const totalLeads = leads.length;
  const qualifiedLeads = leads.filter(l =>
    ['qualified', 'appointment_set', 'consultation_completed', 'converted'].includes(l.status)
  ).length;
  const convertedLeads = leads.filter(l => l.status === 'converted').length;

  const conversionFunnel = [
    {
      stage: 'Page Views',
      count: totalViews,
      percentage: 100,
      color: 'bg-blue-500'
    },
    {
      stage: 'Form Submissions',
      count: totalSubmissions,
      percentage: totalViews > 0 ? Math.round((totalSubmissions / totalViews) * 100) : 0,
      color: 'bg-indigo-500'
    },
    {
      stage: 'Qualified Leads',
      count: qualifiedLeads,
      percentage: totalSubmissions > 0 ? Math.round((qualifiedLeads / totalSubmissions) * 100) : 0,
      color: 'bg-purple-500'
    },
    {
      stage: 'Converted',
      count: convertedLeads,
      percentage: qualifiedLeads > 0 ? Math.round((convertedLeads / qualifiedLeads) * 100) : 0,
      color: 'bg-green-500'
    }
  ];

  // Calculate trends (compare last 15 days to previous 15 days)
  const fifteenDaysAgo = startOfDay(addDays(now, -15));
  const recentLeads = leads.filter(l => new Date(l.createdAt) >= fifteenDaysAgo);
  const olderLeads = leads.filter(l => {
    const createdAt = new Date(l.createdAt);
    return createdAt >= thirtyDaysAgo && createdAt < fifteenDaysAgo;
  });

  const leadsTrend = olderLeads.length > 0
    ? Math.round(((recentLeads.length - olderLeads.length) / olderLeads.length) * 100)
    : recentLeads.length > 0 ? 100 : 0;

  // Serialize leads for display
  const recentLeadsDisplay = leads.slice(0, 10).map(lead => ({
    id: lead.id,
    name: `${lead.firstName || ''} ${lead.lastName || ''}`.trim() || 'Unknown',
    email: lead.email,
    phone: lead.phone,
    status: lead.status,
    temperature: lead.temperature,
    score: lead.score,
    source: lead.utmSource || lead.source,
    utmCampaign: lead.utmCampaign,
    createdAt: lead.createdAt.toISOString()
  }));

  return {
    landingPage: {
      id: landingPage.id,
      name: landingPage.name,
      slug: landingPage.slug,
      url: landingPage.url,
      status: landingPage.status,
      publishedAt: landingPage.publishedAt?.toISOString() ?? null,
      createdAt: landingPage.createdAt.toISOString(),
      template: landingPage.template,
      campaign: landingPage.campaign,
      organization: landingPage.organization
    },
    metrics: {
      totalViews,
      totalSubmissions,
      conversionRate,
      avgLeadScore,
      totalLeads,
      qualifiedLeads,
      convertedLeads,
      leadsTrend
    },
    temperatureDistribution,
    trafficSources,
    utmCampaigns,
    viewsByDay,
    conversionFunnel,
    recentLeads: recentLeadsDisplay
  };
};
